# 统计二进制数中1的个数

## 方法1

```
int setBits(int n) 
{
    int num = 0;
    while(n) 
    {
        if(n & 1) num++;
        n >>= 1;
    }
    return num;
}
```

可以认为是O(32)的算法，但是不能处理负数！会陷入死循环。如：-9 -> -5 -> -2 -> -1 -> -1 -> -1 ...

【注】负数的左移右移位运算和正数有所差别：

- 负数左移: 直接乘以2的移位数次方

- 负数右移：
    1. 先求出该负数的原码
    2. 然后符号位不变，按位取反后加1得到补码
    3. 对补码进行右移，高位补1
    4. 根据移位后的值，符号位不变，按位取反后加1（补码的补码是原码）得到移位后的值的原码，也就得出了移位后的真实值。

## 方法2（方法1的修正版）

为了防止负数处理的死循环，我们可以不改变n，而是维护一个mask让它去统计n上各个位是否为1。此方法对32位的整数会经过32次循环。

```
int setBits(int n) 
{
    int num = 0;
    unsigned int mask = 1;
    while(mask) {
        if(n & mask)
            num++ ;
        mask <<= 1;
    }
    return num;
}
```

## 方法3

```
int setBits(int n) 
{
    int num = 0;
    while(n) {
        num++;
        n &= (n-1);
    }
    return num;
}
```

基本思想：一个数n减去1，相当于它的二进制数中的最后一个1及其之后的位全部取反，因此```n & (n - 1)```即是的整个二进制数的set bits减1。更具体一些，我们可以如下分类讨论：

1. 若二进制数末位为1，则-1后该1变为0。如```n = 1101```，则```n - 1 = 1100```
2. 若二进制数末位为0，则-1会向最后一个1借位，相当于局部取反。如```n = 1000```，则```n - 1 = 0111```

方法3会运行setBits次循环，相对于方法2进行了一个常数优化，但仍然不是O(1)算法。

## 方法4

```
int setBits(int x)
{  
    x = (x & 0x55555555) + ((x & 0xaaaaaaaa) >> 1);  
    x = (x & 0x33333333) + ((x & 0xcccccccc) >> 2);  
    x = (x & 0x0f0f0f0f) + ((x & 0xf0f0f0f0) >> 4);  
    x = (x & 0x00ff00ff) + ((x & 0xff00ff00) >> 8);  
    x = (x & 0x0000ffff) + ((x & 0xffff0000) >> 16);  
    return x;  
} 
```
此为O(1)算法，但目前还没有搞懂为什么，只能说位运算大法好呀。
